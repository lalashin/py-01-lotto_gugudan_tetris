<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Flask ë¯¸ë‹ˆ í”„ë¡œì íŠ¸</title>

<style>
body {
    background:#f4f6f8;
    font-family: Arial, sans-serif;
    padding:40px;
}
.card {
    background:white;
    max-width:900px;
    margin:30px auto;
    padding:30px;
    border-radius:14px;
    box-shadow:0 4px 12px rgba(0,0,0,0.1);
}
.section-title {
    border-bottom:2px solid #eee;
    padding-bottom:10px;
    margin-bottom:20px;
}
button {
    padding:8px 16px;
    margin-top:10px;
    cursor:pointer;
}
input {
    padding:6px;
    margin-top:10px;
}
.numbers {
    display:flex;
    justify-content:center;
    gap:8px;
}
.ball {
    width:40px;
    height:40px;
    border-radius:50%;
    background:#4f46e5;
    color:white;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:bold;
}
table {
    width:100%;
    margin-top:20px;
    border-collapse:collapse;
}
th, td {
    border-bottom:1px solid #ddd;
    padding:10px;
    text-align:center;
}
.notice {
    font-size:12px;
    color:#666;
}

/*í…ŒíŠ¸ë¦¬ìŠ¤*/

h1 { margin: 0 0 10px 0; font-size: 2em; }

    /* ë²„íŠ¼ ì»¨í…Œì´ë„ˆ */
    .controls-ui {
      margin-bottom: 15px;
      display: flex;
      gap: 10px;
    }

    button.tetris-btn {
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      transition: background 0.3s;
    }

    button.tetris-btn:hover { background-color: #45a049; }

    /* ì¢…ë£Œ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë‹¤ë¥´ê²Œ */
    #stop-btn { background-color: #f44336; }
    #stop-btn:hover { background-color: #d32f2f; }

    #game-container {
      position: relative;
      border: 2px solid #fff;
    }

    canvas {
      display: block;
      background-color: #000;
    }

    #score { font-size: 1.5em; margin-bottom: 10px; }

    /* ê²Œì„ ì˜¤ë²„ ë° ëŒ€ê¸° í™”ë©´ ë©”ì‹œì§€ */
    #message-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 20px;
      text-align: center;
      border: 2px solid #fff;
      display: flex; /* ì´ˆê¸°ì—” ë³´ì´ê²Œ ì„¤ì • */
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
</style>
</head>
<body>

<!-- ================= ë¡œë˜ ================= -->
<div class="card">
<h2 class="section-title">ğŸ¯ ë¡œë˜ ë²ˆí˜¸ ìƒì„±ê¸°</h2>

<form method="POST">
<input type="hidden" name="form_type" value="lotto">

<label><input type="radio" name="strategy" value="random" checked> ğŸ² ì™„ì „ ëœë¤</label><br>
<label><input type="radio" name="strategy" value="no_birthday"> ğŸ“… ìƒì¼ ìˆ«ì ì œì™¸</label><br>
<label><input type="radio" name="strategy" value="spread"> ğŸ“ˆ ê³ ë¥¸ ë¶„ì‚° ì „ëµ</label><br><br>

<button name="action" value="single">ğŸ² 1íšŒ ìƒì„±</button>
<button name="action" value="auto">ğŸš€ 10íšŒ ìë™ ìƒì„±</button>
</form>

{% if lotto_results %}
<table>
<tr>
<th>íšŒì°¨</th>
<th>ë²ˆí˜¸</th>
</tr>
{% for row in lotto_results %}
<tr>
<td>{{ loop.index }}</td>
<td>
<div class="numbers">
{% for n in row %}
<div class="ball">{{ n }}</div>
{% endfor %}
</div>
</td>
</tr>
{% endfor %}
</table>

<p><strong>ì´ë¡ ì  1ë“± ë‹¹ì²¨ í™•ë¥ :</strong>
{{ "%.8f"|format(probability) }} %
</p>

<p class="notice">
â€» ì „ëµì€ ë²ˆí˜¸ ìƒì„± ë°©ì‹ì˜ ì°¨ì´ë§Œ ìˆì„ ë¿ ì‹¤ì œ ë‹¹ì²¨ í™•ë¥ ì€ ë™ì¼í•©ë‹ˆë‹¤.
</p>
{% endif %}
</div>

<!-- ================= êµ¬êµ¬ë‹¨ ================= -->
<div class="card">
<h2 class="section-title">âœ–ï¸ êµ¬êµ¬ë‹¨ ê²Œì„</h2>

<p>{{ game_message }}</p>

<form method="POST">
<input type="hidden" name="form_type" value="gugudan">

{% if not game_active %}
    <button name="action" value="start">â–¶ ê²Œì„ì‹œì‘</button>
{% else %}
    <p><strong>{{ a }} Ã— {{ b }} = ?</strong></p>

    <input type="hidden" name="a" value="{{ a }}">
    <input type="hidden" name="b" value="{{ b }}">
    <input type="hidden" name="game_active" value="true">

    <input type="text" name="answer" placeholder="ì •ë‹µ ë˜ëŠ” q ì…ë ¥" required>
    <button name="action" value="answer">ì œì¶œ</button>
{% endif %}
</form>

{% if feedback %}
<p><strong>{{ feedback }}</strong></p>
{% endif %}
</div>

<!-- <div class="card">
  <h2 class="section-title">ğŸŸ¦ í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„</h2>

  <button onclick="startTetris()">â–¶ í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„ ì‹œì‘</button>
  <button onclick="stopTetris()">â–  ê²Œì„ ì¢…ë£Œ</button>

  <canvas id="tetrisCanvas"
          width="240"
          height="400"
          style="display:none; background:#111; margin-top:20px;">
  </canvas>
</div> -->
<!-- <div class="card">
  <h2>ğŸŸ¦ ë‹¨ìˆœ í…ŒíŠ¸ë¦¬ìŠ¤</h2>
  <button onclick="startTetris()">â–¶ ê²Œì„ ì‹œì‘</button>
  <button onclick="stopTetris()">â–  ê²Œì„ ì¢…ë£Œ</button>
  <canvas id="tetrisCanvas" width="240" height="400" style="display:none; background:#111; margin-top:20px;"></canvas>
</div> -->

<!-- <script>
const canvas = document.getElementById("tetrisCanvas");
const ctx = canvas.getContext("2d");
ctx.scale(20,20);

const colors = ["cyan","blue","orange","yellow","green","purple","red"];
const arena = Array.from({length:20},()=> Array(12).fill(0));

const pieces = [
  [[1,1,1],[0,1,0]], // T
  [[1,1],[1,1]],     // O
  [[0,1,1],[1,1,0]], // S
  [[1,1,0],[0,1,1]], // Z
  [[1,1,1,1]],       // I
  [[1,0,0],[1,1,1]], // L
  [[0,0,1],[1,1,1]]  // J
];

let player = {pos:{x:4,y:0}, matrix:null, color:"cyan"};
let dropCounter=0;
let lastTime=0;
let intervalId=null;

// ------------------ ë¸”ë¡ ìƒì„± ------------------
function resetPlayer(){
  const index = Math.floor(Math.random()*pieces.length);
  player.matrix = pieces[index].map(row=>[...row]); // ê¹Šì€ ë³µì‚¬
  player.color = colors[index];
  player.pos.y = 0;
  player.pos.x = 4;
}

// ------------------ íšŒì „ ------------------
function rotate(matrix){
  const N = matrix.length;
  const result = Array.from({length:N},()=> Array(N).fill(0));
  for(let y=0;y<N;y++){
    for(let x=0;x<N;x++){
      result[x][N-1-y] = matrix[y][x];
    }
  }
  return result;
}

// ------------------ ê·¸ë¦¬ê¸° ------------------
function drawMatrix(matrix, offset, color){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value){
        ctx.fillStyle=color;
        ctx.fillRect(x+offset.x, y+offset.y,1,1);
      }
    });
  });
}

function draw(){
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(player.matrix, player.pos, player.color);

  for(let y=0;y<arena.length;y++){
    for(let x=0;x<arena[y].length;x++){
      if(arena[y][x]!==0){
        ctx.fillStyle=colors[arena[y][x]-1];
        ctx.fillRect(x,y,1,1);
      }
    }
  }
}

// ------------------ ì¶©ëŒ ì²´í¬ ------------------
function collide(){
  const m = player.matrix;
  const o = player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0 && (arena[y+o.y] && arena[y+o.y][x+o.x])!==0){
        return true;
      }
    }
  }
  return false;
}

// ------------------ ë¸”ë¡ ê³ ì • ------------------
function merge(){
  player.matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value){
        arena[y+player.pos.y][x+player.pos.x] = colors.indexOf(player.color)+1;
      }
    });
  });
}

// ------------------ ë¸”ë¡ ì´ë™ ------------------
function playerDrop(){
  player.pos.y++;
  if(collide()){
    player.pos.y--;
    merge();
    resetPlayer(); // ë°”ë‹¥ ë‹¿ìœ¼ë©´ ìƒˆ ë¸”ë¡ ìƒì„±
  }
}

// ------------------ í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ------------------
document.addEventListener("keydown", event=>{
  if(!player.matrix) return;

  if(event.key==="ArrowLeft"){
    player.pos.x--;
    if(collide()) player.pos.x++;
  }else if(event.key==="ArrowRight"){
    player.pos.x++;
    if(collide()) player.pos.x--;
  }else if(event.key==="ArrowDown"){
    playerDrop();
  }else if(event.key===" "){ // ìŠ¤í˜ì´ìŠ¤ë°” -> íšŒì „ë§Œ
    const rotated = rotate(player.matrix.map(row=>[...row])); // ê¹Šì€ ë³µì‚¬
    const oldMatrix = player.matrix;
    player.matrix = rotated;
    if(collide()) player.matrix = oldMatrix; // ì¶©ëŒ ì‹œ ì›ìƒë³µê·€
  }
});

// ------------------ ê²Œì„ ë£¨í”„ ------------------
function update(time=0){
  const delta = time-lastTime;
  lastTime=time;
  dropCounter+=delta;
  if(dropCounter>500){
    playerDrop();
    dropCounter=0;
  }
  draw();
  intervalId=requestAnimationFrame(update);
}

// ------------------ ì‹œì‘/ì¢…ë£Œ ------------------
function startTetris(){
  canvas.style.display="block";
  resetPlayer();
  update();
}

function stopTetris(){
  cancelAnimationFrame(intervalId);
  intervalId=null;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  canvas.style.display="none";
  for(let y=0;y<arena.length;y++) arena[y].fill(0);
}
</script> -->

<div class="card">
   <h1>Tetris</h1>
  
  <div class="controls-ui">
    <button class="tetris-btn" id="start-btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
    <button class="tetris-btn" id="stop-btn" onclick="endGame()">ê²Œì„ ì¢…ë£Œ</button>
  </div>

  <div id="score">ì ìˆ˜: 0</div>

  <div id="game-container">
    <canvas width="320" height="640" id="game"></canvas>
    
    <div id="message-overlay">
      <h2 id="overlay-title">Ready?</h2>
      <p id="overlay-desc">ê²Œì„ ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”</p>
    </div>
  </div>
</div>

<script>
    // --- ë³€ìˆ˜ ë° ì„¤ì • ---
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');
    const grid = 32;
    const tetrominoSequence = [];
    const playfield = [];

    // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
    let count = 0;
    let tetromino = null;
    let rAF = null; 
    let gameOver = false;
    let score = 0;
    let isGameActive = false; // ê²Œì„ ì§„í–‰ ì¤‘ ì—¬ë¶€ ì²´í¬

    // ë³´ë“œ ì´ˆê¸°í™”
    for (let row = -2; row < 20; row++) {
      playfield[row] = [];
      for (let col = 0; col < 10; col++) {
        playfield[row][col] = 0;
      }
    }

    // í…ŒíŠ¸ë¡œë¯¸ë…¸ ë°ì´í„°
    const tetrominoes = {
      'I': [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
      'J': [[1,0,0], [1,1,1], [0,0,0]],
      'L': [[0,0,1], [1,1,1], [0,0,0]],
      'O': [[1,1], [1,1]],
      'S': [[0,1,1], [1,1,0], [0,0,0]],
      'Z': [[1,1,0], [0,1,1], [0,0,0]],
      'T': [[0,1,0], [1,1,1], [0,0,0]]
    };

    const colors = {
      'I': 'cyan', 'O': 'yellow', 'T': 'purple', 
      'S': 'green', 'Z': 'red', 'J': 'blue', 'L': 'orange'
    };

    // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateSequence() {
      const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
      while (sequence.length) {
        const rand = getRandomInt(0, sequence.length - 1);
        const name = sequence.splice(rand, 1)[0];
        tetrominoSequence.push(name);
      }
    }

    function getNextTetromino() {
      if (tetrominoSequence.length === 0) generateSequence();
      const name = tetrominoSequence.pop();
      const matrix = tetrominoes[name];
      const col = playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);
      const row = name === 'I' ? -1 : -2;
      return { name, matrix, row, col };
    }

    function rotate(matrix) {
      const N = matrix.length - 1;
      return matrix.map((row, i) => row.map((val, j) => matrix[N - j][i]));
    }

    function isValidMove(matrix, cellRow, cellCol) {
      for (let row = 0; row < matrix.length; row++) {
        for (let col = 0; col < matrix[row].length; col++) {
          if (matrix[row][col] && (
              cellCol + col < 0 ||
              cellCol + col >= playfield[0].length ||
              cellRow + row >= playfield.length ||
              playfield[cellRow + row][cellCol + col])
            ) return false;
        }
      }
      return true;
    }

    function placeTetromino() {
      for (let row = 0; row < tetromino.matrix.length; row++) {
        for (let col = 0; col < tetromino.matrix[row].length; col++) {
          if (tetromino.matrix[row][col]) {
            if (tetromino.row + row < 0) return showGameOver();
            playfield[tetromino.row + row][tetromino.col + col] = tetromino.name;
          }
        }
      }

      for (let row = playfield.length - 1; row >= 0; ) {
        if (playfield[row].every(cell => !!cell)) {
          score += 100;
          document.getElementById('score').innerText = `ì ìˆ˜: ${score}`;
          for (let r = row; r >= 0; r--) {
            for (let c = 0; c < playfield[r].length; c++) {
              playfield[r][c] = playfield[r-1][c];
            }
          }
        } else {
          row--;
        }
      }
      tetromino = getNextTetromino();
    }

    function showGameOver() {
      cancelAnimationFrame(rAF);
      gameOver = true;
      isGameActive = false;
      
      const overlay = document.getElementById('message-overlay');
      document.getElementById('overlay-title').innerText = "GAME OVER";
      document.getElementById('overlay-desc').innerText = `ìµœì¢… ì ìˆ˜: ${score}`;
      overlay.style.display = 'flex';
    }

    // --- ë©”ì¸ ë£¨í”„ ---
    function loop() {
      rAF = requestAnimationFrame(loop);
      context.clearRect(0,0,canvas.width,canvas.height);

      // ë³´ë“œ ê·¸ë¦¬ê¸°
      for (let row = 0; row < 20; row++) {
        for (let col = 0; col < 10; col++) {
          if (playfield[row][col]) {
            const name = playfield[row][col];
            context.fillStyle = colors[name];
            context.fillRect(col * grid, row * grid, grid-1, grid-1);
          }
        }
      }

      if (tetromino) {
        if (++count > 35) {
          tetromino.row++;
          count = 0;
          if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
            tetromino.row--;
            placeTetromino();
          }
        }
        context.fillStyle = colors[tetromino.name];
        for (let row = 0; row < tetromino.matrix.length; row++) {
          for (let col = 0; col < tetromino.matrix[row].length; col++) {
            if (tetromino.matrix[row][col]) {
              context.fillRect((tetromino.col + col) * grid, (tetromino.row + row) * grid, grid-1, grid-1);
            }
          }
        }
      }
    }

    // --- í‚¤ë³´ë“œ ì¡°ì‘ ---
    document.addEventListener('keydown', function(e) {
      // ê²Œì„ ì¤‘ì´ ì•„ë‹ˆê±°ë‚˜ ê²Œì„ ì˜¤ë²„ ìƒíƒœë©´ ì¡°ì‘ ë¶ˆê°€
      if (gameOver || !isGameActive) return;

      if (e.which === 37) { // Left
        const col = tetromino.col - 1;
        if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
      }
      else if (e.which === 39) { // Right
        const col = tetromino.col + 1;
        if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
      }
      else if (e.which === 40) { // Down
        const row = tetromino.row + 1;
        if (!isValidMove(tetromino.matrix, row, tetromino.col)) {
          tetromino.row--;
          placeTetromino();
          return;
        }
        tetromino.row = row;
      }
      else if (e.which === 32) { // Space (Rotate)
        e.preventDefault(); 
        const matrix = rotate(tetromino.matrix);
        if (isValidMove(matrix, tetromino.row, tetromino.col)) tetromino.matrix = matrix;
      }
    });

    // --- ë²„íŠ¼ ê¸°ëŠ¥ ---
    
    function startGame() {
      // ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë©´ ë¦¬ì…‹í• ì§€ ë¬»ê±°ë‚˜, ê·¸ëƒ¥ ë¦¬ì…‹ (ì—¬ê¸°ì„  ë°”ë¡œ ë¦¬ì…‹ ë° ì‹œì‘)
      if (rAF) cancelAnimationFrame(rAF);

      // ë³€ìˆ˜ ì´ˆê¸°í™”
      for (let row = -2; row < 20; row++) {
        for (let col = 0; col < 10; col++) {
          playfield[row][col] = 0;
        }
      }
      score = 0;
      count = 0;
      gameOver = false;
      isGameActive = true;
      
      document.getElementById('score').innerText = 'ì ìˆ˜: 0';
      // ì˜¤ë²„ë ˆì´ ìˆ¨ê¹€
      document.getElementById('message-overlay').style.display = 'none';
      
      tetrominoSequence.length = 0;
      tetromino = getNextTetromino();
      rAF = requestAnimationFrame(loop);
      
      // í¬ì»¤ìŠ¤ë¥¼ ìº”ë²„ìŠ¤ë‚˜ ë°”ë””ë¡œ ëŒë ¤ì„œ ë°”ë¡œ í‚¤ë³´ë“œ ì…ë ¥ ê°€ëŠ¥í•˜ê²Œ í•¨
      document.activeElement.blur();
    }

    function endGame() {
      if (!isGameActive) return; // ì´ë¯¸ êº¼ì ¸ìˆìœ¼ë©´ ë¬´ì‹œ

      cancelAnimationFrame(rAF);
      gameOver = true;
      isGameActive = false;
      
      const overlay = document.getElementById('message-overlay');
      document.getElementById('overlay-title').innerText = "ê²Œì„ ì¢…ë£Œ";
      document.getElementById('overlay-desc').innerText = `í”Œë ˆì´ ì ìˆ˜: ${score}`;
      overlay.style.display = 'flex';
    }

    // í˜ì´ì§€ ë¡œë“œ ì‹œ ìº”ë²„ìŠ¤ ë°°ê²½ë§Œ ê·¸ë ¤ë‘ê¸° (ê²€ì€ìƒ‰)
    context.fillStyle = '#000';
    context.fillRect(0, 0, canvas.width, canvas.height);

  </script>




</body>
</html>
